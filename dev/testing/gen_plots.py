import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import numpy as np
import argparse
import brewer2mpl
from matplotlib.font_manager import FontProperties
# Make sure to install matplotlib and brewer2mpl using pip

# trans_sizes = [1,2,4,8,16]

# labels for x axis
xaxis = [1, 2, 4, 8, 16, 48, 96]

# use 8 colors from the Qualitiative Set1 brewer colors
bmap = brewer2mpl.get_map("Set1", "Qualitative", 8)
colors = bmap.mpl_colors

# map work name to text used in plot legend
label_dict = {"lftt": "PETRA", "romulus": "ROMLOG", "mnemosyne": "MNEM", "pmdk": "PMDK", "originallftt": "LFTT", "dram":"DRAM"}
# cache_dict ={"o": "CLFLUSHOPT", "w":"CLWB", "c":"CLFLUSH"}
plt.rcParams.update({'font.size': '240'})
plt.rc('ytick', labelsize = 280)
# takes data from processed files generated by run_test_mod.py and parses it
def parse_data(filename):
    # maps transaction sizes to a list of y values for that size
    lines = {}
    # Read through the file in chunks to figure out data
    with open(filename, "r") as f:
        file_lines = f.readlines()
        # remove spaces from lines
        file_lines = list(filter(lambda x: not x.isspace(), file_lines))

        # Loop over each chunk of lines and process the data
        # 14 = 2 lines for 7 thread counts per transaction
        for i in range(0, len(file_lines), 14):
            # get current transaction number, should be first line of index every iteration
            cur_trans_size = file_lines[i].split()[2]
            # create a list of the data excluding the previous line and in chunks of 2
            sub_list = file_lines[i + 1 : i + 14 : 2]
            y_vals = []
            # go through the sub list and save the data values
            for line in sub_list:
                y_vals.append(float(line.split()[10]))
            # append the sub list to map
            lines[cur_trans_size] = y_vals

    return lines


def create_plot(files):
    # a is the x axis as a list from 0 - 7, with the labels to be renamed later
    a = np.arange(0, 7) # TODO: temporary change for new thread counts
    # b is the x axis values for Mnemosyne since it has different thread counts
    b = [0, 1, 2, 3, 4, 4.5, 4.8]

    fig, ax = plt.subplots(figsize=(85,80))
    plt.title(input("Enter plot title: "), y=1.035, fontsize=220)  # Get user input to give the title a plot
    plt.ylabel("Throughput (Ops/sec)")
    plt.xlabel("Number of Threads")

    # values to use for the line drawings
    markers = [".--", "^--", "*--", "H--", "s--", "<--", "+--", "x--"]
    color_map = [1, 4]
    # loop through each file, parse and plot the data
    for i, filename in enumerate(files):
        # get y values from file
        lines = parse_data(filename)

        # Figure out which caching mechanism was used by the name of the file
        if "CLFLUSHOPT" in filename:
            cache = "CLFLUSHOPT"
        elif "CLFLUSH" in filename:
            cache = "CLFLUSH"
        elif "CLWB" in filename:
            cache = "CLWB"

        # figure out which approach was used by the name of the file
        if "lftt" in filename:
            work = "lftt"
        elif "romulus" in filename:
            work = "romulus"
        elif "pmdk" in filename:
            work = "pmdk"
        elif "mnemosyne" in filename:
            work = "mnemosyne"
        if "dramlftt" in filename:
            cache= "DRAM"
            work="dram"
            print("found dram!")
        if "original" in filename:
            work="originallftt"


        # Iterate through the key-value pairs of transaction sizes to y values
        # key = transaction size, which isn't really being used right now since they are all 1
        # value is a list of throughputs that are used as the y coordinates to plot
        j = 0
        for key, value in lines.items(): # note, for multiple transactions, this loops several times, may need to use that as the index for the colors list

            # use b for the x coordinates that map to the y coordinates in value .if mnemosyne is being plotted, since it has different thread counts
            # otherwise use a as the x coordinates
            # Note: a/b and value have to be lists of the same length!
            print(f"Plotting {filename}")
            print(f"key = {key}, value = {value}")
            if work == "mnemosyne":
                ax.plot(b, value, markers[i], markersize=200, label=label_dict[work], color=colors[i])
            else:
                ax.plot(a, value, markers[j], markersize=200, label=label_dict[work] + f'-{key}', color=colors[color_map[i]])
            j += 1
    # set y axis to log scale
    # plt.yscale("log")
    ax.set_yscale("log")

    # set labels on x axis to the thread counts
    plt.xticks(a, xaxis)
    # ax.set_xticks(xaxis)

    # set y axis labels
    ax.set_yticks([10, 100, 1000, 10000, 100000, 1000000, 10000000])

    
    legend = plt.legend(loc = "upper left", fontsize=150, ncol=2)
    for handle in legend.legendHandles:
        handle._legmarker.set_markersize(100)
   
    # Render the plot graphically if in in environment to do so
    if args.display:
        plt.show()
    else:
        if args.filename:
            name = args.filename
        else:
            name = input("Enter the filename to save")
        plt.savefig(name, dpi=600)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate plots from formatted test data"
    )
    parser.add_argument("--filename", "-n", help="Filename of plot.")
    parser.add_argument(
        "files", help="Relative path of files you would like to plot", nargs="*"
    )
    parser.add_argument(
        "--display",
        "-d",
        help="Render the plot to the screen if GUI is availablee (Does not auto save file)",
        action="store_true",
    )
    parser.add_argument(
        "--example",
        "-e",
        help="Display an example of how to use this script",
        action="store_true",
    )

    args = parser.parse_args()
    if args.example:
        print(
            "'python3 gen_plots.py 8_lftt_CLFLUSHOPT_1000000_average.txt 8_romulus_CLFLUSHOPT_1000000_average.txt 8_pmdk_CLFLUSHOPT_1000000_average.txt'"
        )
        exit()
    if len(args.files) == 0:
        print("Please provide filenames")
        exit()
    print("Parsing data...")
    create_plot(args.files)
